(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{347:function(e,t,s){"use strict";s.r(t);var r=s(27),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"setting-up-the-projects"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setting-up-the-projects"}},[e._v("#")]),e._v(" Setting up the projects")]),e._v(" "),t("h2",{attrs:{id:"project-structure-with-darkrift"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#project-structure-with-darkrift"}},[e._v("#")]),e._v(" Project Structure with Darkrift")]),e._v(" "),t("p",[e._v("Before we start our project we should take a minute to think about our project structure.\nWe will create a classic FPS game in this tutorial with a server and a client application. The server application will have full control (authoritative server) over the game, so cheating will be impossible.")]),e._v(" "),t("p",[e._v("The client will be a unity game with a normal unity project. For the server we have 2 possibilities:")]),e._v(" "),t("ul",[t("li",[e._v("Use an embedded server (We will also run the server in Unity)")]),e._v(" "),t("li",[e._v("Use a standalone server (The server will be just a C# console application)")])]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("If you use an embedded server you can also create the server and the client in the same project. But you will have to make sure that the client build includes no server code and vice versa which makes it a bit complicated.")])]),e._v(" "),t("h3",{attrs:{id:"reasons-for-an-embedded-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reasons-for-an-embedded-server"}},[e._v("#")]),e._v(" Reasons for an Embedded Server")]),e._v(" "),t("ul",[t("li",[e._v("You can use a similar project structure on your client and server (Monobehaviors)")]),e._v(" "),t("li",[e._v("Access to Unity features like Physics, Navmesh or Collision detection.")]),e._v(" "),t("li",[e._v("You can use graphical outputs for debugging or testing on your server.")])]),e._v(" "),t("h3",{attrs:{id:"reasons-for-a-standalone-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reasons-for-a-standalone-server"}},[e._v("#")]),e._v(" Reasons for a Standalone Server")]),e._v(" "),t("ul",[t("li",[e._v("Less overhead then an embedded server (slightly increased performance)")]),e._v(" "),t("li",[e._v("Easier to manage references and use external libraries (NuGet packages, C# 7 support...)")]),e._v(" "),t("li",[e._v("Easier to containerize and deploy for production")]),e._v(" "),t("li",[e._v("You can still use some Unity functions by referencing the UnityEngine.dll.")])]),e._v(" "),t("p",[e._v("In the end standalone and embedded servers are pretty similar. We will go for an embedded server in this tutorial because we want to use the Unity collision detection and because I usually write standalone applications and want to try something different.")]),e._v(" "),t("h2",{attrs:{id:"setup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[e._v("#")]),e._v(" Setup")]),e._v(" "),t("ul",[t("li",[e._v("Create a repository or folder for the unity projects, name it something like EmbeddedFPSExample")])]),e._v(" "),t("h2",{attrs:{id:"setup-the-client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup-the-client"}},[e._v("#")]),e._v(" Setup the Client")]),e._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[e._v("DANGER")]),e._v(" "),t("p",[e._v("This project uses new physics features which were introduced in Unity 2018.3 so you have to use 2018.3 or a newer version of Unity.")])]),e._v(" "),t("ul",[t("li",[e._v("Create a new Unity project (I called mine EmbeddedFPSClient).")]),e._v(" "),t("li",[e._v("In Edit -> Project Settings -> Player -> Other settings, make sure that Scripting Runtime Version is set to .Net 4.x equivalent.")]),e._v(" "),t("li",[e._v("In Edit -> Project Settings -> Time, set Fixed Timestep to 0.025 and Maximum Allowed Timestep to 100")]),e._v(" "),t("li",[e._v("In Edit => Project Settigs => Physics, set "),t("code",[e._v("Auto Sync Transforms")]),e._v(" to true.")]),e._v(" "),t("li",[e._v("Head to the Asset Store and download the newest version of Darkrift 2.")]),e._v(" "),t("li",[e._v('Create a basic folder structure (create a "Prefabs", "Scenes" and "Scripts" folder)')]),e._v(" "),t("li",[e._v('Create a Scene "Main" in the scenes folder')])]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("Auto Sync Transforms is needed for the reconciliation (correction) code. It could be disabled by using "),t("code",[e._v("Physics.SyncTransforms")]),e._v(" at the right places but was done so for simplicity.")])]),e._v(" "),t("h2",{attrs:{id:"setup-the-server"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setup-the-server"}},[e._v("#")]),e._v(" Setup the Server")]),e._v(" "),t("p",[e._v("Repeat the setup from the client but name the project something like EmbeddedFPSServer")]),e._v(" "),t("h2",{attrs:{id:"creating-a-folder-junction-to-share-scripts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-folder-junction-to-share-scripts"}},[e._v("#")]),e._v(" Creating a Folder Junction to Share Scripts")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("Creating a folder junction to share script is an outdated way of doing this. Since the introduction of the Unity Package Manager I'd recommend using a local package. You can learn more about the Unity Package Manager "),t("a",{attrs:{href:"https://docs.unity3d.com/Manual/Packages.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here."),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("Another option could be to use a separate standalone c# library project and create a dll which is shared between the two projects.")])]),e._v(" "),t("p",[e._v("Some scripts will be used by the client and the server, having a way to synchronize them saves time. There are many good ways to do that. For the sake of simplicity we will use a folder junction. A folder junction synchronizes all files inside a folder to another folder.")]),e._v(" "),t("ul",[t("li",[e._v('Create a "Shared" folder inside the Scripts folder of the client project.')])]),e._v(" "),t("h3",{attrs:{id:"windows"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#windows"}},[e._v("#")]),e._v(" Windows:")]),e._v(" "),t("ul",[t("li",[e._v("open the cmd.exe")]),e._v(" "),t("li",[e._v("type: "),t("code",[e._v('mklink /J "<client-shared-folder>" "<server-shared-folder>"')]),t("br"),e._v("The paths must be absolute for mklink to work e. g. "),t("code",[e._v('mklink /J "C:\\Users\\<user>\\Documents\\EmbeddedFPSExample\\EmbeddedFPSServer\\Assets\\Scripts\\Shared" "C:\\Users\\<user>\\Documents\\EmbeddedFPSExample\\EmbeddedFPSClient\\Assets\\Scripts\\Shared"')])])]),e._v(" "),t("h3",{attrs:{id:"mac-os-x"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mac-os-x"}},[e._v("#")]),e._v(" Mac OS X")]),e._v(" "),t("ul",[t("li",[e._v("open the terminal")]),e._v(" "),t("li",[e._v("type: "),t("code",[e._v('ln -s "<client-shared-folder>" "<server-shared-folder>"')]),e._v("\\")])]),e._v(" "),t("p",[e._v("This junction will share all changes that we make on the client "),t("strong",[e._v("But not the other way around so we will edit scripts in the shared folders always in the clients folder.")])]),e._v(" "),t("p",[e._v("Now the setup is done and we can start to write some code ðŸ˜ƒ")])])}),[],!1,null,null,null);t.default=a.exports}}]);