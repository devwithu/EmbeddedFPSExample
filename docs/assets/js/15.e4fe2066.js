(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{369:function(e,t,a){"use strict";a.r(t);var r=a(45),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"networking-discussion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#networking-discussion"}},[e._v("#")]),e._v(" Networking Discussion")]),e._v(" "),a("p",[e._v("This chapter contains general information about game networking.")]),e._v(" "),a("h2",{attrs:{id:"networking-architectures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#networking-architectures"}},[e._v("#")]),e._v(" Networking Architectures")]),e._v(" "),a("h3",{attrs:{id:"direct-peer-to-peer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#direct-peer-to-peer"}},[e._v("#")]),e._v(" Direct Peer to Peer")]),e._v(" "),a("p",[e._v("Direct peer to peer networking is an architecture in which clients are connected directly to each other. There are 2 popular architectures for direct P2P.\nOne uses a host. Clients will connect directly to the host and the host will get data from all the clients and redistribute data back to them. Another way is to connect each client with each other client and let each client update all other clients. Both architectures have advantages and disadvantages but the host-client architecture is far more popular.")]),e._v(" "),a("h3",{attrs:{id:"relay-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relay-server"}},[e._v("#")]),e._v(" Relay Server")]),e._v(" "),a("p",[e._v("The relay server architecture is similar to the direct host-client P2P architecture. The only difference is that both the host and the clients connect to a central relay server. Data is sent in a similar way as in the host-client\nP2P architecture but all data will be sent over the relay server. The relay server receives packages and redirects them to the host or the clients. The advantage of using a relay server architecture is that it works for anyone out of the box without having players to open ports. It's a very popular architecture for COOP games.")]),e._v(" "),a("h3",{attrs:{id:"nat-punchthrough"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nat-punchthrough"}},[e._v("#")]),e._v(" NAT Punchthrough")]),e._v(" "),a("p",[e._v("NAT Punchthrough allows clients to create direct P2P connections without having to know the other clients ips. The basic idea is to open a port on each client’s NAT by connecting it to a master server and passing all the ips to the other clients while keeping the connection open which allows the clients to receive messages from other clients.\nIn practice it is far more complicated and not always stable or possible, that's why most of the time the master server is also a relay server which will act like a relay server if a connection fails.\nSo why use NAT Punchthrough at all? Direct connections between clients will lower the ping for the players and will also decrease your server bandwidth and cpu load by a lot. Battle.net was initially only powered by a single master server which created direct connections between clients.")]),e._v(" "),a("h3",{attrs:{id:"client-server-authorative-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client-server-authorative-server"}},[e._v("#")]),e._v(" Client-Server/Authorative Server")]),e._v(" "),a("p",[e._v("The idea is similar to host-client direct P2P but the host is a dedicated server and not a client. Clients will connect to the server and send messages to the server and the host will redirect them to the clients. It is highly recommended to give full authority to the server. In some cases the client should have authority over certain actions though (More in the Chapter Authority).")]),e._v(" "),a("h3",{attrs:{id:"room-based-client-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#room-based-client-server"}},[e._v("#")]),e._v(" Room-based Client-Server")]),e._v(" "),a("p",[e._v("It is definitely the most popular type of Client-Server architecture. A room based server features multiple rooms and a way to distribute clients into them. Clients will only be updated about information in their current room.\nThe architecture is very easy to scale because the servers running the rooms don't have to send information to each other. Usually a single master server is used to distribute the players into rooms and to pass information between the servers.")]),e._v(" "),a("h3",{attrs:{id:"seamless-world-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#seamless-world-server"}},[e._v("#")]),e._v(" Seamless World Server")]),e._v(" "),a("p",[e._v("Seamless world servers are usually used in open world MMORPGs. Creating a working seamless world server system needs a lot of knowledge so I won't cover it in detail. But the basic idea is usually to slice your map into areas and have players connected to their current area and nearby areas and if the player passes a border authority is also passed to another server.")]),e._v(" "),a("h3",{attrs:{id:"which-architecture-to-choose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#which-architecture-to-choose"}},[e._v("#")]),e._v(" Which Architecture to choose:")]),e._v(" "),a("p",[e._v("-Direct P2P: Local Lan-Party games\n-Relay Server: COOP/casual games\n-Nat Punchthrough: COOP/Casual games where saving money on servers is important and with an advanced networking programmer in the team.\n-Client-Server: Prototypes or Lan-Party games\n-Room-based Client-Server: Almost all games: MOBAs, MMORPGs, Shooters....\n-Seamless World Server: Huge open world games with thousands of players on the same map.")]),e._v(" "),a("h2",{attrs:{id:"general-game-networking-concepts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#general-game-networking-concepts"}},[e._v("#")]),e._v(" General Game Networking Concepts")]),e._v(" "),a("h3",{attrs:{id:"ticks-update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ticks-update"}},[e._v("#")]),e._v(" Ticks/Update")]),e._v(" "),a("p",[e._v('Most multiplayer games run logic like collisions and movement on a fixed tick rate. One reason for that is that it allows clients to predict movement accurately but it makes games overall more smooth and solves a lot\nof nasty networking issues which otherwise need to be fixed. Running the server and the client at the same tick rate makes everything even easier. If the client and the server use the same tick rate then almost anything can be deterministically calculated and things like lag compensation can be done with tick numbers instead of timestamps.\nWhen using unity make sure to set "Maximum Allowed Timestep" in the time settings to a high value, if you don\'t Unity will skip fixed frames if a lag occurs which brings everything out of sync.\nYou can also easily create your own fixed update by just adding time.DeltaTime to a float in Update and when it exceeds 1/YourDesiredFixedRate you subtract your fixed rate and call your own fixed update method.')]),e._v(" "),a("h3",{attrs:{id:"network-ids"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#network-ids"}},[e._v("#")]),e._v(" Network Ids")]),e._v(" "),a("p",[e._v("A lot of games use network ids to keep track of objects. Usually there are two types of ids. Type ids describe what type an object is (a certain creature or an interactable object or a player) and Network ids are unique numbers for each object. The advantage of such a system is that it makes spawning/despawning and sending information to a specific object very easy. A basic breakdown of the implementation:")]),e._v(" "),a("ul",[a("li",[e._v("Spawning: The server sends a spawn command including an NetworkId,TypeId and TypeSpecificSpawnInformation then both the server and clients spawn that object based on the parameters")]),e._v(" "),a("li",[e._v("Despawning: Is very easy just send a despawn event including the NetworkId of the object and maybe TypeSpecificDespawnInformation")]),e._v(" "),a("li",[e._v("Passing Information: This is where the pattern truly shines. You can send a NetworkId, an EventId and EventSpecificInformation to the client and the client can very easily redirect that information to the right object and execute a method and pass the EventSpecificInformation\nas a parameter. Note that the EventIds can be object specific for instance a player could use the id 1 for a shooting event but a door could use it as an open/close event. This is crucial as it allows the pattern to use very low bandwidth while still being very flexible.")])]),e._v(" "),a("h3",{attrs:{id:"optimization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimization"}},[e._v("#")]),e._v(" Optimization")]),e._v(" "),a("p",[e._v("There are a lot of ways to optimize when it comes to game networking but it's always important to not over optimize things. As a rule of thumb code which runs every tick is worth to optimize everything else isn't unless it's causing notable performance problems. I'm just going to a list a few general tips:")]),e._v(" "),a("ul",[a("li",[e._v("For numbers think about if you really need an int or if an ushort or a byte would also fulfil the purpose.")]),e._v(" "),a("li",[e._v("Optimize base data types like quaternions, bool arrays, angles, vectors "),a("a",{attrs:{href:"https://github.com/LestaAllmaron/DarkriftSerializationExtensions/blob/master/DarkriftSerializationExtensions/DarkriftSerializationExtensions/SerializationExtensions.cs",target:"_blank",rel:"noopener noreferrer"}},[e._v("Example"),a("OutboundLink")],1)]),e._v(" "),a("li",[e._v("Only use strings for names or text messages almost everything else can be serialized far more efficiently. Strings also include JSON strings don’t use JSON for real time games.")]),e._v(" "),a("li",[e._v("Send as much has possible in one message and combine message information into one big message (Most games collect all information for a game tick and send it in 1 message). Sending a message is very expensive.")])])])}),[],!1,null,null,null);t.default=s.exports}}]);